<?php

use Docs\Documentation;
use Docs\MarkdownFormatter;
use Docs\TextFormatter;
use KBC\EventSourcing\AggregateClassNotFoundException;
use KBC\EventSourcing\EventSourcingRepository;

abstract class Specification extends PHPUnit_Framework_TestCase
{
    /**
     * If an exception is thrown, it will be caught in here
     */
    protected $caughtException;

    /**
     * The events generated by the command
     *
     * @var array
     */
    protected $producedEvents = [];

    /**
     * Current state
     *
     * @var
     */
    protected $aggregate;

    /**
     * Given events to build the aggregate
     *
     * @return array
     */
    abstract public function given();

    /**
     * Command to fire
     *
     * @return Command
     */
    abstract public function when();

    /**
     * The command handler
     *
     * @param $repository
     * @return mixed
     */
    abstract public function handler($repository);

    /**
     * The tests that have been executed
     *
     * @var array
     */
    protected static $tests = [];

    /**
     * Setup before class
     */
    public static function setUpBeforeClass()
    {
        static::$tests = [];
    }

    /**
     * TearDown
     */
    public function tearDown()
    {
        static::$tests[] = [
            'name' => $this->getName(),
            'status' => $this->getStatus()
        ];
    }

    /**
     * TearDown after the class
     */
    public static function tearDownAfterClass()
    {
        $documentation = new Documentation('./docs', [
            new TextFormatter(),
            new MarkdownFormatter()
        ]);

        $documentation->generateFor(new static, static::$tests);
    }

    /**
     * @param Exception $exception
     */
    protected function throws(Exception $exception)
    {
        $this->assertInstanceOf(get_class($exception), $this->caughtException);
    }

    /**
     * Setup
     */
    public function setUp()
    {
        try {
            $events = $this->given();

            $fakeRepository = new FakeRepository($events);

            $this->handler($fakeRepository)->handle($this->when());

            $this->producedEvents = $fakeRepository->produced;
            $this->aggregate = $fakeRepository->aggregate;
        } catch (Exception $e) {
            $this->caughtException = $e;
        }
    }
}

class FakeRepository implements EventSourcingRepository
{
    /**
     * @var
     */
    public $aggregate;

    /**
     * @var
     */
    public $previousEvents;

    /**
     * @var
     */
    public $produced;

    /**
     * @var
     */
    public $aggregateClass;

    /**
     * @param $events
     */
    public function __construct($events)
    {
        $this->previousEvents = $events;
    }

    /**
     * @param $class
     * @return mixed
     */
    public function setAggregateClass($class)
    {
        $this->aggregateClass = $class;
    }

    /**
     * @param $id
     * @return mixed
     * @throws AggregateClassNotFoundException
     */
    public function load($id)
    {
        $subject = $this->aggregateClass;

        if (! $subject) {
            throw new AggregateClassNotFoundException();
        }

        return $subject::replayEvents($this->previousEvents);
    }

    /**
     * @param $aggregate
     * @return void
     */
    public function save($aggregate)
    {
        $this->produced = $aggregate->releaseEvents();

        foreach ($this->produced as $event) {
            $aggregate->applyAnEvent($event);
        }

        $this->aggregate = $aggregate;
    }
}
